---
title: "Idempotency"
description: "Ensure safe retry logic and prevent duplicate transactions"
---

# Idempotency

**Prevent duplicate transactions and ensure safe retry logic with Payvessel's idempotency system.**

Idempotency is particularly important for operations that move money, such as **transfers** or **transaction initializations**, to prevent accidental double-charging or double-spending.tended side effects.

<CardGroup cols={2}>
  <Card title="üîÑ Safe Retries" icon="rotate">
    Retry failed requests without creating duplicates
  </Card>
  <Card title="üõ°Ô∏è Duplicate Protection" icon="shield-check">
    Prevent accidental duplicate payments
  </Card>
</CardGroup>

***

## What is Idempotency?

An idempotent operation can be performed multiple times with the same result. In payment processing, this means you can safely retry a payment request without worrying about charging a customer twice.

### üîë Idempotency Key

Include an `Idempotency-Key` header with a unique value for each request:

```bash
curl https://api.payvessel.com/api/v1/payments \
  -H "api-key: PVKEY-3ZO1QOSQH83C5Q3PBCVUT1" \
  -H "api-secret: Bearer PVSECRET-OZJD0SZ2F2WOTXAF" \
  -H "Content-Type: application/json" \
  -H "Idempotency-Key: payment_12345_20241027_001" \
  -d '{
    "amount": 1000,
    "currency": "USD",
    "payment_method": "card"
  }'
```

## How Idempotency Works

<Steps>
  <Step title="First Request">
    Send a request with an idempotency key and process the payment
  </Step>
  <Step title="Subsequent Requests">
    If the same key is used again, return the cached result
  </Step>
  <Step title="Key Expiration">
    Keys expire after 24 hours for security
  </Step>
</Steps>

## Generating Idempotency Keys

### ‚úÖ Best Practices

<AccordionGroup>
  <Accordion icon="key" title="Key Format Guidelines">
    - Use UUIDs or timestamp-based keys
    - Include relevant context (user ID, order ID)
    - Ensure uniqueness across your system
    - Keep keys under 255 characters
    
    **Good examples:**
    - `order_12345_payment_001`
    - `user_67890_subscription_202410`
    - `uuid_550e8400-e29b-41d4-a716-446655440000`
  </Accordion>
  <Accordion icon="clock" title="Key Lifecycle">
    - Keys are valid for 24 hours
    - Same key with different request body returns error
    - Successful requests are cached for full 24 hours
    - Failed requests allow retry with same key
  </Accordion>
</AccordionGroup>

### üîÑ Implementation Examples

<CodeGroup>

```javascript Node.js
const crypto = require('crypto');

// Method 1: UUID-based
function generateIdempotencyKey(orderId) {
  const uuid = crypto.randomUUID();
  return `order_${orderId}_${uuid}`;
}

// Method 2: Timestamp-based
function generateTimestampKey(userId, action) {
  const timestamp = Date.now();
  return `user_${userId}_${action}_${timestamp}`;
}

// Method 3: Hash-based (for consistency)
function generateHashKey(data) {
  const hash = crypto.createHash('sha256')
    .update(JSON.stringify(data))
    .digest('hex');
  return `payment_${hash.substring(0, 16)}`;
}

// Usage
const idempotencyKey = generateIdempotencyKey('12345');
```

```python Python
import uuid
import hashlib
import time
import json

# Method 1: UUID-based
def generate_idempotency_key(order_id):
    unique_id = str(uuid.uuid4())
    return f"order_{order_id}_{unique_id}"

# Method 2: Timestamp-based
def generate_timestamp_key(user_id, action):
    timestamp = int(time.time() * 1000)
    return f"user_{user_id}_{action}_{timestamp}"

# Method 3: Hash-based
def generate_hash_key(data):
    data_str = json.dumps(data, sort_keys=True)
    hash_value = hashlib.sha256(data_str.encode()).hexdigest()
    return f"payment_{hash_value[:16]}"

# Usage
idempotency_key = generate_idempotency_key("12345")
```

```php PHP
<?php
// Method 1: UUID-based
function generateIdempotencyKey($orderId) {
    $uuid = uniqid('', true);
    return "order_{$orderId}_{$uuid}";
}

// Method 2: Timestamp-based
function generateTimestampKey($userId, $action) {
    $timestamp = round(microtime(true) * 1000);
    return "user_{$userId}_{$action}_{$timestamp}";
}

// Method 3: Hash-based
function generateHashKey($data) {
    $dataStr = json_encode($data, JSON_SORT_KEYS);
    $hash = hash('sha256', $dataStr);
    return "payment_" . substr($hash, 0, 16);
}

// Usage
$idempotencyKey = generateIdempotencyKey("12345");
?>
```

</CodeGroup>

## Use Cases

### üí≥ Payment Processing

Prevent duplicate charges when payment requests are retried:

```javascript
// Payment with idempotency
const paymentRequest = {
  amount: 1000,
  currency: 'USD',
  customer_id: 'cust_12345',
  payment_method: 'card'
};

const headers = {
  'api-key': 'PVKEY-3ZO1QOSQH83C5Q3PBCVUT1',
  'api-secret': 'Bearer PVSECRET-OZJD0SZ2F2WOTXAF',
  'Content-Type': 'application/json',
  'Idempotency-Key': `payment_cust_12345_${Date.now()}`
};

// This request can be safely retried
const response = await fetch('https://sandbox.payvessel.com/api/v1/payments', {
  method: 'POST',
  headers,
  body: JSON.stringify(paymentRequest)
});
```

### üîÑ Subscription Billing

Ensure subscription charges aren't duplicated:

```javascript
// Monthly subscription charge
const subscriptionCharge = {
  amount: 2999,
  currency: 'USD',
  customer_id: 'cust_67890',
  subscription_id: 'sub_premium_001'
};

const idempotencyKey = `sub_${subscriptionCharge.subscription_id}_${getCurrentMonth()}`;

// Safe to retry if request fails
const headers = {
  'Idempotency-Key': idempotencyKey,
  // ... other headers
};
```

### üè™ Marketplace Splits

Prevent duplicate vendor payouts:

```javascript
// Marketplace payout
const payoutRequest = {
  amount: 5000,
  currency: 'USD',
  vendor_id: 'vendor_12345',
  order_id: 'order_67890'
};

const idempotencyKey = `payout_${payoutRequest.order_id}_${payoutRequest.vendor_id}`;
```

## Error Handling

### üîÑ Retry Logic

Implement smart retry logic with idempotency:

```javascript
async function safePaymentRequest(paymentData, maxRetries = 3) {
  const idempotencyKey = generateIdempotencyKey(paymentData.order_id);
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch('https://sandbox.payvessel.com/api/v1/payments', {
        method: 'POST',
        headers: {
          'api-key': 'PVKEY-3ZO1QOSQH83C5Q3PBCVUT1',
          'api-secret': 'Bearer PVSECRET-OZJD0SZ2F2WOTXAF',
          'Content-Type': 'application/json',
          'Idempotency-Key': idempotencyKey
        },
        body: JSON.stringify(paymentData)
      });
      
      if (response.ok) {
        return await response.json();
      }
      
      // Don't retry on client errors (4xx)
      if (response.status >= 400 && response.status < 500) {
        throw new Error(`Client error: ${response.status}`);
      }
      
    } catch (error) {
      if (attempt === maxRetries) {
        throw error;
      }
      
      // Exponential backoff
      await new Promise(resolve => 
        setTimeout(resolve, Math.pow(2, attempt) * 1000)
      );
    }
  }
}
```

## Common Pitfalls

<AccordionGroup>
  <Accordion icon="exclamation-triangle" title="Different Request Bodies">
    **Problem:** Using the same idempotency key with different request data
    
    **Result:** Error response - requests must be identical
    
    **Solution:** Generate keys based on request content or use unique keys per request
  </Accordion>
  <Accordion icon="clock" title="Key Reuse">
    **Problem:** Reusing keys after 24-hour expiration
    
    **Result:** New request processed instead of cached response
    
    **Solution:** Track key usage and generate new keys appropriately
  </Accordion>
  <Accordion icon="key" title="Non-Unique Keys">
    **Problem:** Multiple systems generating the same keys
    
    **Result:** Unexpected cached responses
    
    **Solution:** Include system/service identifiers in keys
  </Accordion>
</AccordionGroup>

## Monitoring Idempotency

Track idempotency usage in your application:

```javascript
// Log idempotency key usage
function logIdempotencyUsage(key, isRetry = false) {
  console.log({
    timestamp: new Date().toISOString(),
    idempotency_key: key,
    is_retry: isRetry,
    action: 'payment_request'
  });
}

// Monitor for duplicate key usage
const usedKeys = new Set();

function validateIdempotencyKey(key) {
  if (usedKeys.has(key)) {
    console.warn(`Idempotency key reused: ${key}`);
  }
  usedKeys.add(key);
}
```

<Note>
**Best Practice:** Always use idempotency keys for payment requests, even if you don't plan to retry. This provides protection against accidental duplicates from user actions like double-clicking.
</Note>

<div style={{textAlign: 'center', marginTop: '2rem'}}>

**Ready to implement safe retry logic?**

<CardGroup cols={2}>
  <Card title="üîÑ Best Practices" icon="check-circle" href="/api-basics/best-practices">
    Learn more about API best practices
  </Card>
  <Card title="‚ö†Ô∏è Error Handling" icon="exclamation-triangle" href="/api-basics/errors">
    Understand error responses and handling
  </Card>
</CardGroup>

</div>
